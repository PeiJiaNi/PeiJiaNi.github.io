<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[什么是冒泡排序法？]]></title>
    <url>%2F2019%2F03%2F20%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[冒泡排序（英文：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端，(摘自维基百科)，就和水底的气泡一样，慢慢的往上浮动，气泡也变得越来越大(见上图) 维基百科的介绍难免会比较难以理解，其实小V的对冒泡排序法的理解呢，冒泡排序法无非就是以下步骤： ​ 1、从左到右将数组中的元素两两依次进行比较 ​ 2、再根据比较每次比较的结果决定是否交换元素位置 具体如何做呢？让我们来看一个栗子吧 有6个数组成一个无须的数列：4、5、6、3、2、1，希望从小到大排列 根据冒泡排序法的思想，我们可从左到右将数组中的相邻元素两两比较，根据比较结果来决定是否交换元素位置 第一轮循环 4和5比较，发现4比5小，不交换元素位置 5和6比较，发现5比6小，不交换元素位置 6和3比较，发现6比3大，交换元素位置 6和2比较，发现6比2大，交换位置 6和1比较，发现6比1大，交换位置 如此比较下来，元素6作为数列的最大元素，就好像一个气泡，从水底慢慢往上冒，浮出水面了，到了数组的最右侧 此时，冒泡排序第一轮比较结束了，此时可以认为6所在的区域是一个有序区域，显然，此区域目前也只有6这一个元素 第二轮循环 4和5比较，发现4比5小，不交换元素位置 5和3比较，发现5比3大，交换元素位置 5和2比较，发现5比2大，交换元素位置 5和1比较，发现5比1大，交换元素位置 至此，第二轮比较也结束了，此时有序区域中有两个元素，具体如下： 后续交换细节，也是相同，故此不在赘述，直接给出后续每轮的交换结果 第三轮交换后状态如下： 第四轮交换后状态如下： 第五轮交换后状态如下： 第六轮交换后状态如下： 至此，数组已完成排序，此时所有数字序列已经是有序的了，这就是冒泡排序法排序的思路 看完了思路，让我们来看看冒泡排序法如何使用代码实现吧！ 123456789101112131415161718192021222324252627282930313233343536/** * 冒泡排序法 * 1、原地排序（Sorted in place）。原地排序算法，就是空间复杂度为 O(1) * 2、稳定排序(当两个数大小相等时，我们不做交换即可) * 3、最好时间复杂度:O(1) (1,2,3,4,5,6),最坏时间复杂度O(n^2) (6,5,4,3,2,1) * 平均时间复杂度：O(n^2) 逆序度 = 满有序度 - 有序度,排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有 * 有序度，就说明排序完成了 */public class BubbleSort &#123; /** * 冒泡排序法 * @param a 待排序数组 * @param n 待排序数组长度 */ public static void bubbleSort(int[] array,int n) &#123; if(n &lt;= 1) return; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n-i-1; j++ ) &#123; if(array[j] &gt; array[j+1]) &#123; int tmp = array[j]; array[j] = array[j+1]; array[j+1] = tmp; &#125; &#125; &#125; &#125; public static void main(String[] args)&#123; int[] array = &#123;4,5,6,3,2,1&#125;; bubbleSort(a,6); system.out.println(Arrays.toString(array)); &#125;&#125; 以上代码就是冒泡的实现啦，但是其实冒泡排序算法其实可以再进一步优化的，让我们看看下面这个数组的排序过程，看看聪明的你能不能看出哪里可以进行优化。 栗子如下： 冒泡排序的每一轮结果如下：]]></content>
      <tags>
        <tag>-数据结构与算法 -排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析与统计算法的执行效率和资源消耗]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%88%86%E6%9E%90%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%2F</url>
    <content type="text"><![CDATA[分析与统计算法的执行效率和资源消耗 我们都知道，学数据结构的其中一个目的就是为了我们的程序能跑的更”快“，占用的内存空间更“少”，那么我们应该如何来衡量这两项呢，这就需要用到接下来介绍的方法啦。 闲话少说，现在让我们通过一个小案例开始吧！ Boss：小V，你帮我测试一下这两段完成相同功能代码，看看哪一段代码执行效率更高吧！ 小V：好 有的同学可能会想到以下这个方法——通过分别记录执行每段前后的时间，通过两段代码消耗的时间得知执行效率（注：假设当前都是从1+2+…+100）： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main()&#123; time_t startTime; time_t endTime; time(&amp;startTime); // 代码段一 / 代码段二 time(&amp;endTime); printf("%ld",endTime-startTime); return 0;&#125; 初看上去，小V同学的做法似乎没什么问题，但是仔细一想，这种测试方法实际上存在以下两种弊端： 测试.结果非常依赖测试环境 比如，我们拿同样一段代码，在i3处理器上跑和在i7处理器上跑，结果显然易见，i7处理器的执行速度要比i3处理器快，也就是消耗的时间更少。 测试结果也可能因数据规模的大小而受到影响（注：数据规模是指输入量或者说处理的数据量的多少） 比如，如果测试数据规模太小，测试结果可能无法真实地反应某个算法的执行效率(详细分析见下图) ​ 如上图所示，如若我们数据规模为1，我们就会得出函数f(n) = 2n 的执行次数低于函数g(n) = n^2的执行次数，借此得出错误的结论：f(n) 的时间消耗 &gt; g(n)的时间消耗——&gt;f(n)效率 &gt; g(n)效率 那么，既然以上方法这么不靠谱(实际上，以上这种不靠谱的分析、统计算法的名字叫事后统计法），那么我们后什么靠谱的统计方法呢，这就需要我们的事前分析估算法闪亮登场咯！ 1、事前分析估算法事前分析估算法：在编写程序前，依据统计方法对算法进行估算， 一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：12341、算法采用的策略、方法；2、编译产生的代码质量；3、问题的输入规模；4、机器执行指令的速度； 2和4这两个因素取决于软件和硬件因素，抛开这些，我们衡量一个程序执行时间，主要是通过算法的好坏以及数据规模的大小来得知。 2、何为大 O 复杂度表示法让我们通过前面Boss交给小V的那两个代码段来理解这一概念 显然，第一个代码片段的执行次数为f(n) = 1+(n + 1)+n+1+1+1 = 2n + 4次，而第二个代码片段的执行次数为g(n)=1+1+1=3次 ，假设执行一次的时间为uint_time，那么我们可以得出代码片段1的执行时间T1(n) = T(f(n)) = 2n+4 unit_time，代码片段2的执行时间为 T2(n) = T(g(n)) = 3 unit_time,至此，不难看出代码的执行时间 T(n) 与每行代码的执行次数 n 成正比 ，这其实也就是我们大 O 复杂度表示法 的定义！ T(n)=T(f(n)) 它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。其中f(n)是问题规模n的某个函数。(公式中的 O，表示代码的执行时间 T(n) 与 f(n) 代码的执行时间 T(n) 与 f(n) 表达式成正比） 3、时间复杂度分析 只关注循环执行次数最多的一段代码 栗子如下图： 12345678int cal(int n) &#123; int sum = 0; int i = 1; for (; i &lt;= n; ++i) &#123; sum = sum + i; &#125; return sum;&#125; 其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行的代码，行，所以这块代码要重点分析，通过分析本段代码块中循环次数最多的一段代码，这两行代码被执行了n次，所以不难得出总的时间复杂度为O(n) 加法法则：总复杂度等于量级最大的那段代码的复杂度 让我们来分析如下代码块： 123456789101112131415161718192021222324int cal(int n) &#123; int sum_1 = 0; int p = 1; for (; p &lt; 100; ++p) &#123; sum_1 = sum_1 + p; &#125; int sum_2 = 0; int q = 1; for (; q &lt; n; ++q) &#123; sum_2 = sum_2 + q; &#125; int sum_3 = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) &#123; j = 1; for (; j &lt;= n; ++j) &#123; sum_3 = sum_3 + i * j; &#125; &#125; return sum_1 + sum_2 + sum_3;&#125; 代码块分为三部分： 1. sum_1执行次数为100次，是一个常量的执行时间，与n的规模无关 2. sum_2时间复杂度为O(n) 3. sum_3时间复杂度为O(n^2) 所以总的时间复杂度为O(n）= O（n^2+n+100),结合“4、如何推导大O阶方法”不难得出该代码块的时间复杂度为O(n^2) 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 栗子如下： 12345678910111213141516int cal(int n) &#123; int ret = 0; int i = 1; for (; i &lt; n; ++i) &#123; ret = ret + f(i); &#125; &#125; int f(int n) &#123; int sum = 0; int i = 1; for (; i &lt; n; ++i) &#123; sum = sum + i; &#125; return;&#125; 我们先从cal()函数入手，假设 f() 只是一个普通操作，那第 4～6 行的时间复杂度就是O(n)，则整体的时间复杂度就为O(n),但f(n)并非一个简单操作，其内部是一个for循环，即外部循环每进行一次，内部执行n次操作，所以得出代码实际的时间复杂度为O(n^2) （即嵌套的双层for循环的时间复杂度） 4、如何推导大O阶方法 用常数1取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是1，则去除与这个项相乘的常数。 5、几种常见时间复杂度分析 对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。非多项式量级只有两个：O(2^n) 和 O(n!)。 当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，执行时间也会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。 常数阶O(1) 首先必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。 注：顺序结构、分支结构基本都是常量阶 线性阶O(n) (循环结构) 切入点：要分析算法的复杂度，关键就是分析循环结构的运行情况 对数阶O(logn)与O(nlogn) 由于每次count乘以2之后，就离n更近了一步，也就是说，有多少个2相乘后大于n，则会退出循环。由2^x = n 得到 x =log2^n。所以这个循环的时间复杂度为O(logn) 很容易看出，该代码时间复杂度为O(log3^n) 实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？ 我们知道，对数之间是可以互相转换的，由对数换底公式loga^b = loga^c logc^b可得 log3^n =log3^2 log2^n，所以 O(log3^n) = O(C * log2^n)，其中 C=log3^2 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2^n) = O(log3^n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。 理解了前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn) 平方阶O(n^2) 内层循环时间复杂度为O(n),再循环n次。所以这段代码的时间复杂度为O(n^2)。 如果外循环循环次数为m，时间复杂度就变为O(m * n)。 总结： O(1)&lt; O(log^n)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)]]></content>
      <tags>
        <tag>-数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法定义、特性及要求]]></title>
    <url>%2F2019%2F03%2F12%2F%E7%AE%97%E6%B3%95%E5%AE%9A%E4%B9%89%E3%80%81%E7%89%B9%E6%80%A7%E5%8F%8A%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[算法定义、特性及要求1、算法定义算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 2、算法特性1、输入输出 算法有零个或多个输入，至少有一个或多个输出。 2、有穷性 算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。 3、确定性 算法的每一步骤都具有确定的含义，不会出现二义性。（同入同出）。 4、可行性 算法的每一步必须是可行的，也就是说，每一步都能够通过执行有限次数完成。 3、算法设计的要求1、正确性 算法的正确性是指算法至少应具有输入、输出及加工处理无歧义性、能正确反映问题需求、能得到问题的正确答案（即输入输出、确定性以及能解决问题） 没有语法错误 对于合法的输入数据能够产生满足要求的输出结果 对于非法的输入数据能够得出满足规格说明的结果(衡量标准) 对于精心挑选的，甚至刁难的测试数据都有满足要求的输出结果 2、可读性 方便阅读、理解与交流 3、健壮性 当输入数据不合法时，算法能做出相关处理，而不是产生异常或莫名其妙的结果 4、时间效率高和存储量低（空间效率高）]]></content>
      <tags>
        <tag>-数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构基本概念]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1、数据结构基本概念和术语1.1、数据数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符合集合。数据，其实就是符号，而这些符号必须具备两个前提： 1. 可以输入到计算机中。 2. 能被计算机程序处理。 数据包括： 数值类型：整型、实型等； 非数值类型：字符及声音、图像、视频等； 1.2、数据元素数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 比如： 人类(数据)中，数据元素为人(组成该类) 畜类(数据)中，牛、马、羊等都是该类的数据元素(组成该类) 1.3、数据项数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位，但真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点。 比如： 人(数据元素)可以有眼、耳、鼻、嘴、脚（数据项），也可以有姓名、性别（数据项）（具体要哪些数据项，要视系统决定）。 1.4、数据对象 数据对象：是性质相同（指数据元素具有相同数量和类型的数据项）的数据元素的集合，是数据的子集。 数据对象为数据的子集，在实际应用中，处理的数据元素通常具有相同性质（即处理的是数据对象），所以，在不产生混淆的情况下，我们都讲数据对象简称为数据。 1.5、数据结构总结： 2、逻辑结构和物理结构2.1、逻辑结构​ 逻辑结构是指数据对象中数据元素之间的相互关系。 2.1.1、分类 集合结构：集合结构中的数据元素除了同属于一个集合外，之间没有其他关系 线性结构：线性结构中的数据元素之间是一对一的关系 树形结构：树形结构中的数据元素存在一种一对多的层次关系 图型结构：图型结构的数据元素之间存在一种多对多的关系 注意： ​ 使用示意图表示数据的逻辑结构时，将每一个数据元素看做一个结点，用圆圈表示 ​ 元素之间的逻辑关系用结点之间的连线表示，如果关系是有方向的，则用带箭头的连线表示 2.2、物理结构（存储结构) 物理结构是指数据的逻辑结构在计算机中的存储方式（如何将逻辑结构转换为物理结构，即把数据元素存储到存储器中，存储结构应反映数据元素之间的逻辑关系） 分类： 顺序存储结构：数据元素存放于地址连续的存储单元里，数据间的逻辑关系和物理关系是一致的 链式存储结构：数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 总结： 3、抽象数据类型3.1、数据类型​ 数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 3.1.1、数据类型分类 原子类型：不可再分解的类型，包括实型，整型，字符型等 结构类型：由若干个类型组合而成，可分解。例如整型数组是由若干整型数据组成的。 3.2、抽象数据类型（Abstract Data Type,ADT）抽象数据类型是指一个数学模型及定义在该模型上的一组操作。一个抽象数据类型定义了：一个数据对象、数据对象中各数据元素之间的关系以及对数据元素的操作 (抽象：抽象是抽取出事物具有的普遍的本质。隐藏了繁杂的细节，只保留了实现目标所必须的信息。)]]></content>
      <tags>
        <tag>-数据结构与算法</tag>
      </tags>
  </entry>
</search>
