<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Voldemort的博客</title>
  
  <subtitle>勿在浮沙筑高楼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://PeiJiaNi.github.io/"/>
  <updated>2019-03-13T13:41:45.486Z</updated>
  <id>https://PeiJiaNi.github.io/</id>
  
  <author>
    <name>PeiJiaNi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分析与统计算法的执行效率和资源消耗</title>
    <link href="https://PeiJiaNi.github.io/2019/03/13/%E5%88%86%E6%9E%90%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97/"/>
    <id>https://PeiJiaNi.github.io/2019/03/13/分析与统计算法的执行效率和资源消耗/</id>
    <published>2019-03-13T11:43:47.000Z</published>
    <updated>2019-03-13T13:41:45.486Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，学数据结构的其中一个目的就是为了我们的程序能跑的更”快”，占用的内存空间更“少”，那么我们应该如何来衡量这两项呢，这就需要用到接下来介绍的方法啦。</p><p>闲话少说，现在让我们通过一个小案例开始吧！</p><p>Boss：小V，你帮我测试一下这两段完成相同功能代码，看看哪一段代码执行效率更高吧！</p><p>小V：好，此时小V应该如何做呢？</p><p>有的同学可能会想到以下这个方法——通过分别记录执行每段前后的时间，通过两段代码消耗的时间得知执行效率（注：假设当前都是从1+2+…+100）：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main(){    time_t startTime;    time_t endTime;    time(&amp;startTime);    // 代码段一 / 代码段二    time(&amp;endTime);    printf(&quot;%ld&quot;,endTime-startTime);    return 0;}</code></pre><p>初看上去，小V同学的做法似乎没什么问题，但是仔细一想，这种测试方法实际上存在以下两种弊端：</p><ol><li>测试.结果非常依赖测试环境<br>比如，我们拿同样一段代码，在i3处理器上跑和在i7处理器上跑，结果显然易见，i7处理器的执行速度要比i3处理器快，也就是消耗的时间更少。</li><li><p>测试结果也可能因数据规模的大小而受到影响（注：数据规模是指输入量或者说处理的数据量的多少）<br>比如，如果测试数据规模太小，测试结果可能无法真实地反应某个算法的执行效率(详细分析见下图)</p><p> 如上图所示，如若我们数据规模为1，我们就会得出函数f(n) = 2n 的执行次数低于函数g(n) = n^2的执行次数，借此得出错误的结论：f(n) 的时间消耗 &gt; g(n)的时间消耗——&gt;f(n)效率 &gt; g(n)  </p></li></ol><p>那么，既然以上方法这么不靠谱(实际上，以上这种不靠谱的分析、统计算法的名字叫事后统计法），那么我们后什么靠谱的统计方法呢，这就需要我们的事前分析估算法闪亮登场咯！</p><p>1、事前分析估算法</p><p>事前分析估算法：在编写程序前，依据统计方法对算法进行估算，</p><p>一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</p><pre><code>1、算法采用的策略、方法；2、编译产生的代码质量；3、问题的输入规模；4、机器执行指令的速度；</code></pre><p>2和4这两个因素取决于软件和硬件因素，抛开这些，我们衡量一个程序执行时间，主要是通过算法的好坏以及数据规模的大小来得知。</p><p>2、何为大 O 复杂度表示法</p><p>让我们通过前面Boss交给小V的那两个代码段来理解这一概念</p><p>显然，第一个代码片段的执行次数为f(n) = 1+(n + 1)+n+1+1+1 = 2n + 4次，而第二个代码片段的执行次数为g(n)=1+1+1=3次 ，假设执行一次的时间为uint_time，那么我们可以得出代码片段1的执行时间T1(n) = T(f(n)) = 2n+4 unit_time，代码片段2的执行时间为 T2(n) = T(g(n)) = 3 unit_time,至此，不难看出代码的执行时间 T(n) 与每行代码的执行次数 n 成正比 ，这其实也就是我们大 O 复杂度表示法 的定义！</p><pre><code>&lt;blockquote class=&quot;blockquote-center&quot;&gt;T(n)=T(f(n))&lt;/blockquote&gt;</code></pre><p>T(n)=O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。其中f(n)是问题规模n的某个函数。(公式中的 O，表示代码的执行时间 T(n) 与 f(n) 代码的执行时间 T(n) 与 f(n) 表达式成正比</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们都知道，学数据结构的其中一个目的就是为了我们的程序能跑的更”快”，占用的内存空间更“少”，那么我们应该如何来衡量这两项呢，这就需要用到接下来介绍的方法啦。&lt;/p&gt;
&lt;p&gt;闲话少说，现在让我们通过一个小案例开始吧！&lt;/p&gt;
&lt;p&gt;Boss：小V，你帮我测试一下这两段完成相
      
    
    </summary>
    
    
      <category term="-数据结构与算法" scheme="https://PeiJiaNi.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法定义、特性及要求</title>
    <link href="https://PeiJiaNi.github.io/2019/03/12/%E7%AE%97%E6%B3%95%E5%AE%9A%E4%B9%89%E3%80%81%E7%89%B9%E6%80%A7%E5%8F%8A%E8%A6%81%E6%B1%82/"/>
    <id>https://PeiJiaNi.github.io/2019/03/12/算法定义、特性及要求/</id>
    <published>2019-03-12T13:37:01.000Z</published>
    <updated>2019-03-12T13:54:31.327Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="算法定义-特性及要求">算法定义、特性及要求</span></h1><h2><span id="1-算法定义">1、算法定义</span></h2><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><h2><span id="2-算法特性">2、算法特性</span></h2><p>1、输入输出</p><p>算法有零个或多个输入，至少有一个或多个输出。</p><p>2、有穷性</p><p>算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p><p>3、确定性</p><p>算法的每一步骤都具有确定的含义，不会出现二义性。（同入同出）。</p><p>4、可行性</p><p>算法的每一步必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</p><a id="more"></a><h2><span id="3-算法设计的要求">3、算法设计的要求</span></h2><p>1、正确性</p><p>算法的正确性是指算法至少应具有输入、输出及加工处理无歧义性、能正确反映问题需求、能得到问题的正确答案（即输入输出、确定性以及能解决问题）</p><ul><li>没有语法错误</li><li>对于合法的输入数据能够产生满足要求的输出结果</li><li>对于非法的输入数据能够得出满足规格说明的结果(衡量标准)</li><li>对于精心挑选的，甚至刁难的测试数据都有满足要求的输出结果</li></ul><p>2、可读性</p><p>方便阅读、理解与交流</p><p>3、健壮性</p><p>当输入数据不合法时，算法能做出相关处理，而不是产生异常或莫名其妙的结果</p><p>4、时间效率高和存储量低（空间效率高）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法定义、特性及要求&quot;&gt;&lt;a href=&quot;#算法定义、特性及要求&quot; class=&quot;headerlink&quot; title=&quot;算法定义、特性及要求&quot;&gt;&lt;/a&gt;算法定义、特性及要求&lt;/h1&gt;&lt;h2 id=&quot;1、算法定义&quot;&gt;&lt;a href=&quot;#1、算法定义&quot; class=&quot;headerlink&quot; title=&quot;1、算法定义&quot;&gt;&lt;/a&gt;1、算法定义&lt;/h2&gt;&lt;p&gt;算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。&lt;/p&gt;
&lt;h2 id=&quot;2、算法特性&quot;&gt;&lt;a href=&quot;#2、算法特性&quot; class=&quot;headerlink&quot; title=&quot;2、算法特性&quot;&gt;&lt;/a&gt;2、算法特性&lt;/h2&gt;&lt;p&gt;1、输入输出&lt;/p&gt;
&lt;p&gt;算法有零个或多个输入，至少有一个或多个输出。&lt;/p&gt;
&lt;p&gt;2、有穷性&lt;/p&gt;
&lt;p&gt;算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。&lt;/p&gt;
&lt;p&gt;3、确定性&lt;/p&gt;
&lt;p&gt;算法的每一步骤都具有确定的含义，不会出现二义性。（同入同出）。&lt;/p&gt;
&lt;p&gt;4、可行性&lt;/p&gt;
&lt;p&gt;算法的每一步必须是可行的，也就是说，每一步都能够通过执行有限次数完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-数据结构与算法" scheme="https://PeiJiaNi.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基本概念</title>
    <link href="https://PeiJiaNi.github.io/2019/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://PeiJiaNi.github.io/2019/03/11/数据结构基本概念/</id>
    <published>2019-03-11T13:09:36.000Z</published>
    <updated>2019-03-12T13:54:29.189Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="1-数据结构基本概念和术语">1、数据结构基本概念和术语</span></h1><h2><span id="11-数据">1.1、数据</span></h2><p><strong>数据</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符合集合。数据，其实就是符号，而这些符号必须具备两个前提：</p><p>　1. 可以输入到计算机中。<br>　2. 能被计算机程序处理。</p><p><strong>数据包括</strong>：</p><ol><li>数值类型：整型、实型等；</li><li>非数值类型：字符及声音、图像、视频等；</li></ol><h2><span id="12-数据元素">1.2、数据元素</span></h2><p><strong>数据元素</strong>：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><pre><code>比如：    人类(数据)中，数据元素为人(组成该类)    畜类(数据)中，牛、马、羊等都是该类的数据元素(组成该类)</code></pre><h2><span id="13-数据项">1.3、数据项</span></h2><p><strong>数据项</strong>：一个数据元素可以由若干个数据项组成。数据项是数据<strong>不可分割</strong>的最小单位，但真正讨论问题时，<strong>数据元素才是数据结构中建立数据模型的着眼点</strong>。</p><pre><code>比如：　人(数据元素)可以有眼、耳、鼻、嘴、脚（数据项），也可以有姓名、性别（数据项）（具体要哪些数据项，要视系统决定）。</code></pre><a id="more"></a><h2><span id="14-数据对象">1.4、数据对象</span></h2><p>　<strong>数据对象</strong>：是性质相同（指数据元素具有<strong>相同数量</strong>和<strong>类型</strong>的数据项）的数据元素的集合，是数据的子集。</p><p>　数据对象为数据的子集，在实际应用中，处理的数据元素通常具有相同性质（即处理的是数据对象），所以，在不产生混淆的情况下，我们都讲数据对象简称为数据。</p><h2><span id="15-数据结构">1.5、数据结构</span></h2><p>总结：</p><p><img src="/2019/03/11/数据结构基本概念/data.png" alt="img"></p><h1><span id="2-逻辑结构和物理结构">2、逻辑结构和物理结构</span></h1><h2><span id="21-逻辑结构">2.1、逻辑结构</span></h2><p>​    逻辑结构是指数据对象中数据元素之间的相互关系。</p><h3><span id="211-分类">2.1.1、分类</span></h3><ul><li><strong>集合结构</strong>：集合结构中的数据元素除了同属于一个集合外，之间没有其他关系</li></ul><p><img src="/2019/03/11/数据结构基本概念/collection.png" alt="img"></p><ul><li><strong>线性结构</strong>：线性结构中的数据元素之间是一对一的关系</li></ul><p><img src="/2019/03/11/数据结构基本概念/linear.png" alt="img"></p><ul><li><strong>树形结构</strong>：树形结构中的数据元素存在一种一对多的层次关系</li></ul><p><img src="/2019/03/11/数据结构基本概念/tree.png" alt="img"></p><ul><li><strong>图型结构</strong>：图型结构的数据元素之间存在一种多对多的关系</li></ul><p><img src="/2019/03/11/数据结构基本概念/map.png" alt="img"></p><p><strong>注意</strong>：</p><p>​    使用示意图表示数据的逻辑结构时，将每一个数据元素看做一个结点，用圆圈表示</p><p>​    元素之间的逻辑关系用结点之间的连线表示，如果关系是有方向的，则用带箭头的连线表示</p><h2><span id="22-物理结构存储结构">2.2、物理结构（存储结构)</span></h2><p>  物理结构是指数据的逻辑结构在计算机中的存储方式（如何将逻辑结构转换为物理结构，即把数据元素存储到存储器中，存储结构应反映数据元素之间的逻辑关系）</p><p>分类：</p><ul><li>顺序存储结构：数据元素存放于地址连续的存储单元里，数据间的逻辑关系和物理关系是一致的</li></ul><p><img src="/2019/03/11/数据结构基本概念/SeqList.png" alt="img"></p><ul><li>链式存储结构：数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</li></ul><p><img src="/2019/03/11/数据结构基本概念/LinkList.png" alt="img"></p><p>总结：</p><p><img src="/2019/03/11/数据结构基本概念/Summary.png" alt="img"></p><h1><span id="3-抽象数据类型">3、抽象数据类型</span></h1><h2><span id="31-数据类型">3.1、数据类型</span></h2><p>​    数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p><h3><span id="311-数据类型分类">3.1.1、数据类型分类</span></h3><ul><li>原子类型：不可再分解的类型，包括实型，整型，字符型等</li><li>结构类型：由若干个类型组合而成，可分解。例如整型数组是由若干整型数据组成的。  </li></ul><h2><span id="32-抽象数据类型abstract-data-typeadt">3.2、抽象数据类型（Abstract Data Type,ADT）</span></h2><p>抽象数据类型是指一个数学模型及定义在该模型上的一组操作。一个抽象数据类型定义了：一个<strong>数据对象</strong>、数据<strong>对象中各数据元素之间的关系</strong>以及<strong>对数据元素的操作</strong>  (抽象：抽象是抽取出事物具有的普遍的本质。隐藏了繁杂的细节，只保留了实现目标所必须的信息。)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、数据结构基本概念和术语&quot;&gt;&lt;a href=&quot;#1、数据结构基本概念和术语&quot; class=&quot;headerlink&quot; title=&quot;1、数据结构基本概念和术语&quot;&gt;&lt;/a&gt;1、数据结构基本概念和术语&lt;/h1&gt;&lt;h2 id=&quot;1-1、数据&quot;&gt;&lt;a href=&quot;#1-1、数据&quot; class=&quot;headerlink&quot; title=&quot;1.1、数据&quot;&gt;&lt;/a&gt;1.1、数据&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符合集合。数据，其实就是符号，而这些符号必须具备两个前提：&lt;/p&gt;
&lt;p&gt;　1. 可以输入到计算机中。&lt;br&gt;　2. 能被计算机程序处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据包括&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数值类型：整型、实型等；&lt;/li&gt;
&lt;li&gt;非数值类型：字符及声音、图像、视频等；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-2、数据元素&quot;&gt;&lt;a href=&quot;#1-2、数据元素&quot; class=&quot;headerlink&quot; title=&quot;1.2、数据元素&quot;&gt;&lt;/a&gt;1.2、数据元素&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数据元素&lt;/strong&gt;：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;比如：
    人类(数据)中，数据元素为人(组成该类)
    畜类(数据)中，牛、马、羊等都是该类的数据元素(组成该类)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-3、数据项&quot;&gt;&lt;a href=&quot;#1-3、数据项&quot; class=&quot;headerlink&quot; title=&quot;1.3、数据项&quot;&gt;&lt;/a&gt;1.3、数据项&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数据项&lt;/strong&gt;：一个数据元素可以由若干个数据项组成。数据项是数据&lt;strong&gt;不可分割&lt;/strong&gt;的最小单位，但真正讨论问题时，&lt;strong&gt;数据元素才是数据结构中建立数据模型的着眼点&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;比如：
　人(数据元素)可以有眼、耳、鼻、嘴、脚（数据项），也可以有姓名、性别（数据项）（具体要哪些数据项，要视系统决定）。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="-数据结构与算法" scheme="https://PeiJiaNi.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
