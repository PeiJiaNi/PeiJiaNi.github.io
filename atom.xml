<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Voldemort的博客</title>
  
  <subtitle>勿在浮沙筑高楼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://PeiJiaNi.coding.me/"/>
  <updated>2019-06-27T05:27:25.772Z</updated>
  <id>https://PeiJiaNi.coding.me/</id>
  
  <author>
    <name>PeiJiaNi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>切勿使用For循环遍历LinkedList</title>
    <link href="https://PeiJiaNi.coding.me/2019/06/27/%E5%88%87%E5%8B%BF%E4%BD%BF%E7%94%A8For%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86LinkedList/"/>
    <id>https://PeiJiaNi.coding.me/2019/06/27/切勿使用For循环遍历LinkedList/</id>
    <published>2019-06-27T01:48:02.000Z</published>
    <updated>2019-06-27T05:27:25.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/06/27/切勿使用For循环遍历LinkedList/0.jpg" alt width="100%/"><br><a id="more"></a></p><h1><span id="一-普通for循环遍历arraylist和linkedlist">一、普通For循环遍历ArrayList和LinkedList</span></h1><p>在日常工作中，相信很多朋友经常使用到集合中ArrayList和LinkedList，假如此时让你对两者做遍历操作，那么你是否是使用以下的写法呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化arrayList和linkedList</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">arrayList.add(i);</span><br><span class="line">linkedList.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通For循环遍历ArrayList</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">arrayList.get(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通For循环遍历LinkedList</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">linkedList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用普通For循环遍历ArrayList并没有什么问题，但是使用普通For循环来遍历LinkedList却是<font color="#ff0000"><b>一种很糟糕的做法</b></font>，为什么这么说呢？让我们用事实来说话吧！</p><h1><span id="二-性能对比">二、性能对比</span></h1><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collectionPro.arrayListVsLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> LIST_LENGTH = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LIST_LENGTH; i++) &#123;</span><br><span class="line">arrayList.add(i);</span><br><span class="line">linkedList.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">arrayList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"ArrayList遍历速度："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">linkedList.get(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"LinkedList使用For循环遍历速度："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不断增大LIST_LENGTH,测试结果如下：</p><table><thead><tr><th></th><th style="text-align:center">1000</th><th style="text-align:center">5000</th><th style="text-align:center">10000</th><th style="text-align:center">40000</th><th style="text-align:center">100000</th></tr></thead><tbody><tr><td>ArrayList</td><td style="text-align:center">0ms</td><td style="text-align:center">0ms</td><td style="text-align:center">1ms</td><td style="text-align:center">3ms</td><td style="text-align:center">6ms</td></tr><tr><td>LinkedList</td><td style="text-align:center">4ms</td><td style="text-align:center">20ms</td><td style="text-align:center">49ms</td><td style="text-align:center">710ms</td><td style="text-align:center">5144ms</td></tr></tbody></table><p>从运行结果我们看到，随着List容量的不断增长，ArrayList的遍历耗费时间相对比较稳定，而LinkedList的遍历几乎是爆发式的增长，为什么会出现这样的情况呢？</p><p>让我们先抛出两个问题，然后再逐一击破：</p><p><b>问题一：</b>为什么ArrayList使用For循环遍历速度快于LinkedList呢？<br><b>问题二：</b>如若使用For循环遍历LinkedList是一种糟糕的做法，那我该用什么方法来遍历LinkedList呢？</p><h1><span id="三-问题剖析">三、问题剖析</span></h1><p>首先来看看问题一，<b>为什么ArrayList使用For循环遍历速度快于LinkedList呢？</b></p><p>这其实关乎到ArrayList和LinkedList底层实现的差别——ArrayLis底层是使用数组来实现的，而LinkedList底层是使用双向链表实现的，底层实现所依赖的数据结构不同，也使得其遍历方式也有所不同。</p><p>先来看看ArrayList的get方法源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">RangeCheck(index);</span><br><span class="line"><span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中不难看出，其实ArrayList的get方法只是从数组中取指定位置上的元素值，然后作为返回值返回而已。也就是说<font color="#ff0000"><b>ArrayList的get方法的时间复杂度为O(1),所以使用For循环遍历ArrayList的时间复杂度为O(n)，n为ArrayList的容量。</b></font>    这也就是说明，get方法的时间复杂度是一个常数，和数组的大小并没有给出关系，也就是说想要获取某个位置的数据，只需要给出该数据所在处的索引值，即可定位到该数据。</p><p>这样说可能有的同学还不是很能理解为什么get方法的时间复杂度是O(1)，下面举个小小的栗子来解释下</p><p>通过阅读上面的内容，我们知道ArrayList底层实现是使用数组这种数据结构实现的，那我们来看看数组是如何获取指定索引处的值的。</p><p>假如有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1,2,3&#125;;</span><br></pre></td></tr></table></figure><p>我们知道，在计算机底层，每个数据都是有地址的，就好像我们家里的门牌号一样。那么我写了这样一行代码，计算机内部会如何做呢？</p><p>首先由于Java中一个int型数据是4个字节，而我们所声明的nums数组的长度为3，也就是该数组中有三个int类型的元素，此时计算机就会在内存在开辟一块连续的、足以存放3个4字节也就是12字节的数组的内存空间，并返回该内存空间的首地址。好比首地址为0x00,那么内存中的存放情况即如下图所示：</p><p><img src="/2019/06/27/切勿使用For循环遍历LinkedList/1.jpg" alt width="50%/"></p><p>了解了数组在内存中是如何存储值的，那么根据索引值获取元素值就很简单了，每次获取nums[index]元素值时，其实都是通过公式 <font color="#ff0000"><b>数组首地址+sizeof(type)*index</b></font>算出指定元素的起始地址，然后去该地址中取数据。（好比取nums[1]的时候，计算机就会算出nums[1]的数据是存放在以0x04开头，占据4个字节空间的内存中，因此，计算机会从0x04~0x07这块地址空间中读取数据出来。）<br>从公式可以看出,该过程和数组的大小并没有任何关系，这也就是为什么get方法的时间复杂度为O(1)的原因所在了。</p><p>再来看看LinkedList的get源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> entry(index).element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">entry</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                     <span class="string">", Size: "</span>+size);</span><br><span class="line">Entry&lt;E&gt; e = header;</span><br><span class="line"><span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++)</span><br><span class="line">e = e.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--)</span><br><span class="line">e = e.previous;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>为什么使用普通For循环遍历LinkedList会这么慢呢，原因其实就在于10、11行，通过观察我们可以得出<font color="#ff0000"><b>LinkedList在get任何一个位置的数据的时候，都会把前面的数据走一遍</b></font><br>即如下所示：</p><p>1、get(0)，直接拿到0位的Node0的地址，拿到Node0里面的数据</p><p>2、get(1)，直接拿到0位的Node0的地址，从0位的Node0中找到下一个1位的Node1的地址，找到Node1，拿到Node1里面的数据</p><p>3、get(2)，直接拿到0位的Node0的地址，从0位的Node0中找到下一个1位的Node1的地址，找到Node1，从1位的Node1中找到下一个2位的Node2的地址，找到Node2，拿到Node2里面的数据。</p><p>后面的以此类推。</p><p>故此不难得出<font color="#ff0000"><b>LinkedList的get方法的时间复杂度为O(n),所以使用For循环遍历LinikedList的时间复杂度为O(n^2)，n为LinkedList的容量。</b></font></p><p>通过对比使用普通For循环遍历ArrayList和LinkedList的时间复杂度，也就明白了为什么ArrayList的速度优于LinkedList</p><p>再来看看问题二，<b>如若使用For循环遍历LinkedList是一种糟糕的做法，那我该用什么方法来遍历LinkedList呢？</b></p><p>答案是：使用迭代器或者foreach循环（foreach循环的内部实现就是迭代器）去遍历LinkedList即可</p><p>原因：迭代器中因为next引用的存在使得遍历无需每次都把前面的数据走一遍，故<font color="#ff0000"><b>使用迭代器遍历LinikedList的时间复杂度为O(n)，n为LinkedList的容量。</b></font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/06/27/切勿使用For循环遍历LinkedList/0.jpg&quot; alt width=&quot;100%/&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://PeiJiaNi.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://PeiJiaNi.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈浅拷贝与深拷贝</title>
    <link href="https://PeiJiaNi.coding.me/2019/05/03/%E6%B5%85%E8%B0%88%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://PeiJiaNi.coding.me/2019/05/03/浅谈浅拷贝与深拷贝/</id>
    <published>2019-05-03T04:33:39.000Z</published>
    <updated>2019-05-03T07:23:04.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/05/03/浅谈浅拷贝与深拷贝/0.jpg" alt width="100%/"></p><a id="more"></a><h1><span id="一-定义">一、定义</span></h1><p><strong>浅拷贝：</strong>对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p><p><img src="/2019/05/03/浅谈浅拷贝与深拷贝/1.jpg" alt width="70%/"></p><p><strong>深拷贝：</strong>对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p><p><img src="/2019/05/03/浅谈浅拷贝与深拷贝/2.jpg" alt width="70%/"></p><h1><span id="二-java中的clone方法">二、Java中的Clone()方法</span></h1><p>在 Java 中，所有的 Class 都继承自 Object ，而在 Object 类，有一个 clone() 方法，它被声明为了 protected ，所以我们可以在其子类中，使用它。无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。</p><p>在使用它来实现浅/深拷贝之前，让我们来了解一下关于clone()方法的用法</p><p>clone()方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this &#123;<span class="doctag">@code</span> Object&#125;. The default</span></span><br><span class="line"><span class="comment"> * implementation returns a so-called "shallow" copy: It creates a new</span></span><br><span class="line"><span class="comment"> * instance of the same class and then copies the field values (including</span></span><br><span class="line"><span class="comment"> * object references) from this instance to the new instance. A "deep" copy,</span></span><br><span class="line"><span class="comment"> * in contrast, would also recursively clone nested objects. A subclass that</span></span><br><span class="line"><span class="comment"> * needs to implement this kind of cloning should call &#123;<span class="doctag">@code</span> super.clone()&#125;</span></span><br><span class="line"><span class="comment"> * to create the new instance and then create deep copies of the nested,</span></span><br><span class="line"><span class="comment"> * mutable objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a copy of this object.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> *             if this object's class does not implement the &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *             Cloneable&#125; interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Cloneable)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException(<span class="string">"Class doesn't implement Cloneable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> internalClone((Cloneable) <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Native helper method for cloning.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> Object <span class="title">internalClone</span><span class="params">(Cloneable o)</span></span>;</span><br></pre></td></tr></table></figure><p> 可以看到，clone方法首先会判对象是否实现了Cloneable接口，若无实现Cloneable接口，则会抛出CloneNotSupportedException异常, 否则则会调用internalClone. intervalClone是一个native方法，一般来说native方法的执行效率高于非native方法。</p><p> 当某个类要复写clone方法时，要继承Cloneable接口。通常的克隆对象都是通过super.clone()方法来克隆对象。</p><h1><span id="三-浅拷贝与深拷贝">三、浅拷贝与深拷贝</span></h1><h2><span id="31-浅拷贝">3.1、浅拷贝</span></h2><p> <strong>浅拷贝代码示例</strong>：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age,String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">22</span>,<span class="string">"张三"</span>);</span><br><span class="line">Person p2 = (Person) p1.clone();</span><br><span class="line">System.out.println(<span class="string">"p1 = "</span> + p1);</span><br><span class="line">System.out.println(<span class="string">"p2 = "</span> + p2);</span><br><span class="line">System.out.println(<span class="string">"p1 == p2: "</span> + (p1 == p2));</span><br><span class="line">System.out.println(<span class="string">"p1中name属性的hashCode:"</span> + p1.getName().hashCode());</span><br><span class="line">System.out.println(<span class="string">"p2中name属性的hashCode:"</span> + p2.getName().hashCode());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p1 = Person@6d06d69c</span></span><br><span class="line"><span class="comment">p2 = Person@7852e922</span></span><br><span class="line"><span class="comment">p1 == p2: false</span></span><br><span class="line"><span class="comment">p1中name属性的hashCode:774889</span></span><br><span class="line"><span class="comment">p2中name属性的hashCode:774889</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，使用 clone() 方法，从 == 和 hashCode 的不同可以看出，clone() 方法实则是真的创建了一个新的对象。</p><p>但更深入的看，即从p1与p2对象中name属性的hashcode值相同可知，本次拷贝只是浅拷贝(对基本数据类型(本例中的age属性)进行值传递，对引用数据类型(本例中的name属性)进行引用的拷贝)</p><p>也由上可知，Clone()方法默认实现的是浅拷贝，那么该如何实现深拷贝呢？让我们继续往下看吧！</p><h2><span id="32-深拷贝">3.2、深拷贝</span></h2><p> 为了在要clone对象的时候进行深拷贝而不是浅拷贝，我们应该实现Clonable接口，覆盖并实现clone()方法，除了调用Object类的clone()方法拷贝对象外，还应该将该类中引用变量所指向的对象也拷贝出来(创建一个新的xxx类的对象，并复制其内容)。</p><p> <strong>深拷贝代码示例</strong>：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> public class TestDeapthCopy &#123;</span><br><span class="line">static class Body implements Cloneable&#123;</span><br><span class="line">    public Head head;</span><br><span class="line">    public Body() &#123;&#125;</span><br><span class="line">    public Body(Head head) &#123;this.head = head;&#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Body newBody =  (Body) super.clone();</span><br><span class="line">        newBody.head = (Head) head.clone();</span><br><span class="line">        return newBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Head implements Cloneable&#123;</span><br><span class="line">    public  Face face;</span><br><span class="line"></span><br><span class="line">    public Head() &#123;&#125;</span><br><span class="line">    public Head(Face face)&#123;this.face = face;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">static class Face&#123;&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">    Body body1 = new Body(new Head(new Face()));</span><br><span class="line"></span><br><span class="line">    Body body2 = (Body) body1.clone();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;body1 == body2 : &quot; + (body1 == body2) );</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;body1.head == body2.head : &quot; +  (body1.head == body2.head));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;body1.head.face == body2.head.face : &quot; +  (body1.head.face == body2.head.face));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">body1 == body2 : false</span><br><span class="line">body1.head == body2.head : false</span><br><span class="line">body1.head.face == body2.head.face : true</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>在以上代码中，有以下几个类：TestDeapthCopy类用于测试深拷贝，其他的为内部类，分别为Body、Head、Face。</p><p>在Body中，组合了Head，Head中组合了Face。站在Body这个类的层面上看,对Body对象进行拷贝的时候，也对他组合的Head类的对象进行了拷贝（创建一个新的Head类的对象，并复制其内容），故可称以上代码实现了深拷贝，但倘若再深入一层看，即站在Head类层面上看，head类中组合了Face，但在进行拷贝时对Head类中的Face对象只是拷贝了引用,并未创建一个新的Face类对象且复制其内容（由body1.head.face == body2.head.face : true可得知），故也可以说Body对象的拷贝其实也只是浅拷贝。</p><p>倘若真的要实现完全的深拷贝，那么在对Head对象进行拷贝的同时，也需要对其中组合的Face对象进行拷贝（即在拷贝Head类型的同时，也要创建一个新的Face类的对象，并复制其内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static class Head implements Cloneable&#123;</span><br><span class="line">    public  Face face;</span><br><span class="line"></span><br><span class="line">    public Head() &#123;&#125;</span><br><span class="line">    public Head(Face face)&#123;this.face = face;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        //return super.clone();</span><br><span class="line">        Head newHead = (Head) super.clone();</span><br><span class="line">        newHead.face = (Face) this.face.clone();</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static class Face implements Cloneable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">body1 == body2 : false</span><br><span class="line">body1.head == body2.head : false</span><br><span class="line">body1.head.face == body2.head.face : false</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>由此也可得出，要实现完全的深拷贝是比较麻烦的，如要实现完全的深拷贝，只能将组合中的对象一级一级的显式拷贝，所以创建彻底的深拷贝是非常麻烦的，尤其是在引用关系非常复杂的情况下， 或者在引用链的某一级上引用了一个第三方的对象， 而这个对象没有实现clone方法， 那么在它之后的所有引用的对象都是被共享的。    </p><p>最后笔者想说，理解深拷贝与浅拷贝的区别，还是相当有必要的，如在创建不可变对象时，可能对程序有着微妙的影响，可能会决定我们创建的不可变对象是不是真的不可变。关于不可变类，可参加另外一篇文章。</p><p>（参考博客：<a href="https://segmentfault.com/a/1190000010648514）" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010648514）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/05/03/浅谈浅拷贝与深拷贝/0.jpg&quot; alt width=&quot;100%/&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://PeiJiaNi.coding.me/categories/Java/"/>
    
    
      <category term="Java" scheme="https://PeiJiaNi.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何利用ngrok实现内网穿透</title>
    <link href="https://PeiJiaNi.coding.me/2019/04/30/%E5%88%A9%E7%94%A8ngrok%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://PeiJiaNi.coding.me/2019/04/30/利用ngrok实现内网穿透/</id>
    <published>2019-04-30T11:19:39.000Z</published>
    <updated>2019-05-03T07:12:53.896Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/30/利用ngrok实现内网穿透/0.jpg" alt width="100%/"></p><a id="more"></a><h1><span id="一-什么是ngrok">一、什么是ngrok</span></h1><p> ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放，更加通俗的说，ngrok能够将你局域网的应用映射到公网中，在公网能被访问。</p><h1><span id="二-ngrok的下载安装">二、ngrok的下载安装</span></h1><p><strong>官方下载安装网址</strong>：<a href="https://ngrok.com/download" target="_blank" rel="noopener">https://ngrok.com/download</a></p><h2><span id="1-点击注册用户">1、点击注册用户</span></h2><p><img src="/2019/04/30/利用ngrok实现内网穿透/1.png" alt width="100%/"></p><p><img src="/2019/04/30/利用ngrok实现内网穿透/2.jpg" alt width="100%/"></p><h2><span id="2-复制ngrok秘钥后续需要用到">2、复制ngrok秘钥（后续需要用到）</span></h2><p><img src="/2019/04/30/利用ngrok实现内网穿透/3.jpg" alt width="100%/"></p><p><img src="/2019/04/30/利用ngrok实现内网穿透/4.jpg" alt width="100%/"></p><h2><span id="3-进入网址选择相应版本进行下载">3、进入网址选择相应版本进行下载</span></h2><p><img src="/2019/04/30/利用ngrok实现内网穿透/5.jpg" alt width="100%/"></p><h2><span id="4-下载完成后进行解压操作然后在路径地址栏上输入-cmd-回车">4、下载完成后，进行解压操作，然后在路径地址栏上输入 cmd 回车</span></h2><p><img src="/2019/04/30/利用ngrok实现内网穿透/6.jpg" alt width="100%/"></p><p><img src="/2019/04/30/利用ngrok实现内网穿透/7.jpg" alt width="100%/"></p><h2><span id="5-在cmd窗口中输入ngrok-authtoken-复制的秘钥-然后回车确定">5、在cmd窗口中输入ngrok authtoken 复制的秘钥 然后回车确定</span></h2><p><img src="/2019/04/30/利用ngrok实现内网穿透/8.jpg" alt width="100%/"></p><h2><span id="然后输入ngrok-help-查看认证情况">、然后输入ngrok help 查看认证情况</span></h2><p><img src="/2019/04/30/利用ngrok实现内网穿透/9.jpg" alt width="100%/"></p><h2><span id="7-解析内网ip以tomcat为例">7、解析内网ip，以tomcat为例</span></h2><h3><span id="71-启动tomcat服务">7.1、启动tomcat服务</span></h3><p><img src="/2019/04/30/利用ngrok实现内网穿透/10.jpg" alt width="100%/"><br><img src="/2019/04/30/利用ngrok实现内网穿透/11.jpg" alt width="100%/"></p><h3><span id="72-cmd窗口中中输入-ngrok-http-tomcat端口号默认为8080即可出现映射的域名">7.2、cmd窗口中中输入 ngrok http tomcat端口号(默认为8080)即可出现映射的域名</span></h3><p><img src="/2019/04/30/利用ngrok实现内网穿透/12.jpg" alt width="100%/"></p><h3><span id="73-利用生成的域名进行访问测试">7.3、利用生成的域名进行访问测试</span></h3><p><img src="/2019/04/30/利用ngrok实现内网穿透/13.jpg" alt width="100%/"></p><h1><span id="三-使用总结">三、使用总结</span></h1><p><strong>优点：</strong> 下载安装及使用简单<br><strong>缺点：</strong>由于是国外的服务器，访问起来比较慢，不太稳定，并且映射的外网地址每次都会改变</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/04/30/利用ngrok实现内网穿透/0.jpg&quot; alt width=&quot;100%/&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://PeiJiaNi.coding.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://PeiJiaNi.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>什么是选择排序法？(Selection Sort)</title>
    <link href="https://PeiJiaNi.coding.me/2019/03/23/%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%9F/"/>
    <id>https://PeiJiaNi.coding.me/2019/03/23/什么是选择排序法？/</id>
    <published>2019-03-23T03:13:27.000Z</published>
    <updated>2019-05-03T07:12:39.317Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/03/23/什么是选择排序法？/SelectionSort.png" alt width="100%/"></p><a id="more"></a><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的末尾位置（起始位置），然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。（引自维基百科）</p><p>其实说白了就是以下步骤：<br>    1、首先从原始数组中选择最小的一个数据，将其和位于第一个位置的数据进行交换。<br>    2、接着从剩下的 n-1 个数据中选择次小的一个元素，将其和第二个位置的数据交换。<br>    3、然后，这样不断重复，直到最后连个数据完成交换。至此，便完成对原始数组的从小到大的排序。</p><p>具体是怎样实现的呢？让我们来看看一下栗子，理解选择排序法的思路吧</p><p><img src="/2019/03/23/什么是选择排序法？/1.jpg" alt width="50%/"></p><p>有6个数组成一个无序的数列：4、5、6、3、2、1，希望从小到大排列</p><p><strong>第一轮：</strong></p><p>首轮选择排序前，有序区为空</p><p><img src="/2019/03/23/什么是选择排序法？/2.jpg" alt width="50%/"></p><p>然后我们寻找无序区的最小值，并记录其索引位置。我们可以假设无序区中的最后一个数是最小值，并记录下其索引位置(如：min = array.length - 1)，然后依次和前面的数比较，如果前面出现了更小的数，则更新min为该值的索引位置：(具体过程如下图)</p><p><img src="/2019/03/23/什么是选择排序法？/3.jpg" alt width="50%/"></p><p>1和2比较，发现1小于2，不更新min指针的值</p><p>1和3比较，发现1小于3，不更新min指针的值</p><p>1和6比较，发现1小于6，不更新min指针的值</p><p>1和5比较，发现1小于5，不更新min指针的值</p><p>无序区比较结束，此时在无序区中找到的最小值为1，该值的索引位置记录在min变量中(min = 5)</p><p><img src="/2019/03/23/什么是选择排序法？/4.jpg" alt width="50%/"></p><p>然后将最小值与无序区第一个位置的值进行位置交换，即1和4交换位置(交换后有序区从左往右有一个元素：1)</p><p><img src="/2019/03/23/什么是选择排序法？/5.jpg" alt width="50%/"></p><p><strong>第二轮：</strong></p><p>第二轮选择排序前，有序区中元素只有一个元素1：</p><p><img src="/2019/03/23/什么是选择排序法？/6.jpg" alt width="50%/"></p><p>然后我们继续寻找无序区的最小值，并记录其索引位置。我们仍然假设无序区中的最后一个数是最小值，并记录下其索引位置(如：min = array.length - 1)，然后依次和前面的数比较，如果前面出现了更小的数，则更新min为该值的索引位置：(具体过程如下图)</p><p><img src="/2019/03/23/什么是选择排序法？/7.jpg" alt width="50%/"></p><p>4和2比较，发现4大于2，更新min指针的值</p><p><img src="/2019/03/23/什么是选择排序法？/8.jpg" alt width="50%/"></p><p>2和3比较，发现2小于3，不更新min指针的值</p><p>2和6比较，发现2小于6，不更新min指针的值</p><p>2和5比较，发现2小于5，不更新min指针的值</p><p>无序区比较结束，此时在无序区中找到的最小值为2，该值的索引位置记录在min变量中(min = 4)</p><p><img src="/2019/03/23/什么是选择排序法？/9.jpg" alt width="50%/"></p><p>然后将最小值与无序区第一个位置的值进行位置交换，即2和5交换位置(交换后有序区从左往右共有两个元素：1、2)</p><p><img src="/2019/03/23/什么是选择排序法？/10.jpg" alt width="50%/"></p><p>后续操作也是如此，也就不再赘述了。</p><p>接下来让我们看看选择排序法的代码实现吧！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 选择排序算法</span><br><span class="line">* 选择排序空间复杂度为 O(1)，是一种原地排序算法。</span><br><span class="line">* 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都是O(n^2)</span><br><span class="line">* @param a 待排序数组</span><br><span class="line">* @param n 待排序数组长度</span><br><span class="line">*/</span><br><span class="line">public static void selectionSort(int[] a,int n) &#123;</span><br><span class="line">for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    int min = n-1;                  // 假设最后一个数是最小数</span><br><span class="line">    int temp = 0;                   // 用以进行数据交换</span><br><span class="line">    for(int j = n-1; j &gt; i; j--) &#123;  // 限制无序区内进行比较</span><br><span class="line">        if(a[j-1] &lt; a[min]) &#123;       // 如果前面有数比a[min]索引的值小,则记录该数索引位置</span><br><span class="line">            min  = j-1;             // 记录当前最小数索引位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 一轮比较之后再将最小值与a[i]交换</span><br><span class="line">    temp = a[min];</span><br><span class="line">    a[min] = a[i];</span><br><span class="line">    a[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/03/23/什么是选择排序法？/SelectionSort.png&quot; alt width=&quot;100%/&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://PeiJiaNi.coding.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://PeiJiaNi.coding.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="https://PeiJiaNi.coding.me/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>什么是冒泡排序法？(BubbleSort)</title>
    <link href="https://PeiJiaNi.coding.me/2019/03/20/%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%9F/"/>
    <id>https://PeiJiaNi.coding.me/2019/03/20/什么是冒泡排序法？/</id>
    <published>2019-03-20T08:39:10.000Z</published>
    <updated>2019-05-03T07:12:43.110Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/03/20/什么是冒泡排序法？/Bubble.jpg" alt width="100%/"><br><a id="more"></a><br><strong>冒泡排序</strong>（英文：Bubble Sort）是一种简单的<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">排序算法</a>。它重复地走访过要排序的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%88%97" target="_blank" rel="noopener">数列</a>，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端，(摘自维基百科)，就和水底的气泡一样，慢慢的往上浮动，气泡也变得越来越大(见上图)</p><p>维基百科的介绍难免会比较难以理解，其实小V的对冒泡排序法的理解呢，冒泡排序法无非就是以下步骤：</p><p>​    1、从左到右将数组中的元素两两依次进行比较</p><p>​    2、再根据比较每次比较的结果决定是否交换元素位置</p><p>具体如何做呢？让我们来看一个栗子吧</p><p><img src="/2019/03/20/什么是冒泡排序法？/1.jpg" alt width="40%/"></p><p>有6个数组成一个无须的数列：4、5、6、3、2、1，希望从小到大排列</p><p>根据冒泡排序法的思想，我们可从左到右<strong>将数组中的相邻元素两两比较，根据比较结果来决定是否交换元素位置</strong></p><p><strong>第一轮循环</strong></p><p>4和5比较，发现4比5小，不交换元素位置</p><p>5和6比较，发现5比6小，不交换元素位置</p><p>6和3比较，发现6比3大，交换元素位置</p><p><img src="/2019/03/20/什么是冒泡排序法？/2.jpg" alt width="40%/"></p><p>6和2比较，发现6比2大，交换位置</p><p><img src="/2019/03/20/什么是冒泡排序法？/3.jpg" alt width="40%/"></p><p>6和1比较，发现6比1大，交换位置</p><p><img src="/2019/03/20/什么是冒泡排序法？/4.jpg" alt width="40%/"></p><p>如此比较下来，元素6作为数列的最大元素，就好像一个气泡，从水底慢慢往上冒，浮出水面了，到了数组的最右侧</p><p>此时，冒泡排序第一轮比较结束了，此时可以认为6所在的区域是一个有序区域，显然，此区域目前也只有6这一个元素</p><p><img src="/2019/03/20/什么是冒泡排序法？/5.jpg" alt width="40%/"></p><p><strong>第二轮循环</strong></p><p>4和5比较，发现4比5小，不交换元素位置</p><p>5和3比较，发现5比3大，交换元素位置</p><p><img src="/2019/03/20/什么是冒泡排序法？/6.jpg" alt width="40%/"></p><p>5和2比较，发现5比2大，交换元素位置</p><p><img src="/2019/03/20/什么是冒泡排序法？/7.jpg" alt width="40%/"></p><p>5和1比较，发现5比1大，交换元素位置</p><p><img src="/2019/03/20/什么是冒泡排序法？/8.jpg" alt width="40%/"></p><p>至此，第二轮比较也结束了，此时有序区域中有两个元素，具体如下：</p><p><img src="/2019/03/20/什么是冒泡排序法？/9.jpg" alt width="40%/"></p><p>后续交换细节，也是相同，故此不在赘述，直接给出后续每轮的交换结果</p><p>第三轮交换后状态如下：</p><p><img src="/2019/03/20/什么是冒泡排序法？/10.jpg" alt width="40%/"></p><p>第四轮交换后状态如下：</p><p><img src="/2019/03/20/什么是冒泡排序法？/11.jpg" alt width="40%/"></p><p>第五轮交换后状态如下：</p><p><img src="/2019/03/20/什么是冒泡排序法？/12.jpg" alt width="40%/"></p><p>第六轮交换后状态如下：</p><p><img src="/2019/03/20/什么是冒泡排序法？/13.jpg" alt width="40%/"></p><p>至此，数组已完成排序，此时所有数字序列已经是有序的了，这就是冒泡排序法排序的思路</p><p>我们再来看看该无序数列的整体排序的动态图，加深下理解吧！</p><p><img src="/2019/03/20/什么是冒泡排序法？/BubbleAnimation.gif" alt width="50%/"></p><p>捋清了思路，让我们来看看冒泡排序法如何使用代码实现吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序法</span></span><br><span class="line"><span class="comment"> *  1、原地排序（Sorted in place）。原地排序算法，就是空间复杂度为 O(1)</span></span><br><span class="line"><span class="comment"> *  2、稳定排序(当两个数大小相等时，我们不做交换即可)</span></span><br><span class="line"><span class="comment"> *  3、最好时间复杂度:O(1) (1,2,3,4,5,6),最坏时间复杂度O(n^2) (6,5,4,3,2,1)</span></span><br><span class="line"><span class="comment"> *     平均时间复杂度：O(n^2) 逆序度 = 满有序度 - 有序度,排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有</span></span><br><span class="line"><span class="comment"> *     有序度，就说明排序完成了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 待排序数组长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i-<span class="number">1</span>; j++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">       </span><br><span class="line">        bubbleSort(a,<span class="number">6</span>);</span><br><span class="line">        system.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是冒泡的实现啦，但是其实冒泡排序算法其实可以再进一步优化的，让我们看看下面这个数组的排序过程，看看聪明的你能不能看出哪里可以进行优化。</p><p>栗子如下：</p><p><img src="/2019/03/20/什么是冒泡排序法？/14.jpg" alt width="40%/"></p><p>冒泡排序的每一轮结果如下：</p><p><img src="/2019/03/20/什么是冒泡排序法？/15.jpg" alt width="60%/"></p><p>仔细观察我们会发现，除了第1、2轮冒泡时有数据交换外，后续的几轮冒泡都没有进行数据交换了，换句话说，其实也就意味着，在第3轮冒泡时，没有进行数据交换，也就意味着，无序数列已经变成一个有序数列了，此时我们就可以提前结束冒泡排序了。</p><p>话不多说，让我们直接来看看实现代码吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进一步优化冒泡排序法--&gt;当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，</span></span><br><span class="line"><span class="comment"> * 不用再继续执行后续的冒泡操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a  待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n  待排序数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">refineBubbleSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;          <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i-<span class="number">1</span>; j++) &#123;  <span class="comment">// 注意j取值范围,防止数组索引越界</span></span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                isSorted = <span class="keyword">false</span>;         <span class="comment">// 表示有数据交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;               <span class="comment">// 当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，退出排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处使用布尔类型的isSorted变量作为标志位，每轮排序之前置true，然后数列之间依次两两进行比较，如果有数据交换，则将isSorted变量置为false,如果某轮比较结束后，isSorted值仍为true，则表明冒泡操作已经没有数据交换时，已经达到完全有序，提前退出排序。</p><p>再次献上动图！(通过动图也可以看到，第三轮比较结束后，发现没有数据交换时，就提前退出了冒泡排序)</p><p><img src="/2019/03/20/什么是冒泡排序法？/BubbleAnimation2.gif" alt width="50%/"></p><p>没想到吧，居然还能进行这样的优化，不过，其实这只是冒泡排序的优化的第一步哦，其实还可以继续优化的，让我们通过下面这个例子来发现问题并再次改善冒泡排序吧。</p><p><img src="/2019/03/20/什么是冒泡排序法？/16.jpg" alt width="50%/"></p><p><strong>第一轮：</strong></p><p>4和1比较，发现4比1大，交换元素位置</p><p><img src="/2019/03/20/什么是冒泡排序法？/17.jpg" alt width="50%/"></p><p>4和3比较，发现4比3大，交换元素位置</p><p><img src="/2019/03/20/什么是冒泡排序法？/18.jpg" alt width="50%/"></p><p>4和2比较，发现4比2大，交换元素位置</p><p><img src="/2019/03/20/什么是冒泡排序法？/19.jpg" alt width="50%/"></p><p>4和5比较，发现4比5小，不交换元素位置</p><p>5和6比较，发现5比6小，不交换元素位置</p><p>6和7比较，发现6比7小，不交换元素位置</p><p>7和8比较，发现7比8小，不交换元素位置</p><p>第一轮循环结束，有序区域只有一个元素：</p><p><img src="/2019/03/20/什么是冒泡排序法？/20.jpg" alt width="50%/"></p><p><strong>第二轮：</strong></p><p>1和3比较，发现1比3小，不交换元素位置</p><p>3和比较，发现3比2大，交换元素位置</p><p><img src="/2019/03/20/什么是冒泡排序法？/21.jpg" alt width="50%/"></p><p>3和4比较，发现3比4小，不交换元素位置</p><p>4和5比较，发现4比5小，不交换元素位置</p><p>5和6比较，发现5比6小，不交换元素位置</p><p>6和7比较，发现6比7小，不交换元素位置</p><p>7和8比较，发现7比8小，不交换元素位置</p><p>第二轮循环结束，有序区域此时有两个元素：</p><p><img src="/2019/03/20/什么是冒泡排序法？/22.jpg" alt width="50%/"></p><p>聪明的小伙伴们发现问题了吗？</p><p>是的，没错，仔细观察，我们会发现在排序的过程中，所谓的无序数列的右边，其实很多已经是有序的了，但是每次循环的时候，我们还是进行比较操作，这就是问题所在，也是我们优化的点</p><p>这个问题产生的原因呢，是因为我们代码中规定了，每轮比较过后，有序区域只能增加一个元素：</p><p>第一轮冒泡操作后，有序区域中元素个数由0个变成1个</p><p>第二轮冒泡操作后，有序区域中元素个数由1个变成2个</p><p>第三轮冒泡操作后，有序区域中元素个数由2个变成3个</p><p>……</p><p>第n轮冒泡操作后，有序区域中元素个数由n-1个变成n个（n &lt;= array.length）</p><p>但是实际上，有序区域的增长并不是固定每次只能递增1的，好比上述栗子，第二轮操作后，后面的5个元素已经属于有序区域了，也就是说有序区域中元素个数应该是5，而不是2</p><p>那么如何解决这个问题呢，我们可以在每一轮比较过后，记录下最后一次元素交换时的位置，该位置就是无序区域的边缘了，然后再往后，就是有序边界了</p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4 1 3 2 5 6 7 8</span></span><br><span class="line"><span class="comment"> * 1 3 2 4 5 6 7 8    sortBorder:2</span></span><br><span class="line"><span class="comment"> * 1 2 3 4 5 6 7 8    sortBorder:1</span></span><br><span class="line"><span class="comment"> * 1 2 3 4 5 6 7 8    1和2比较，发现1不大于2，此时退出循环，因isSorted=true，跳出循环，比较结束，数据已经完全有序</span></span><br><span class="line"><span class="comment"> * 进一步优化冒泡排序法--&gt;数列有序区间动态界定</span></span><br><span class="line"><span class="comment"> * 不用再继续执行后续的冒泡操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a  待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n  待排序数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bestRefineBubbleSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sortBorder = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;  <span class="comment">// 注意j取值范围,防止数组索引越界</span></span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                isSorted = <span class="keyword">false</span>;              <span class="comment">// 表示有数据交换</span></span><br><span class="line">                lastExchangeIndex = j;         <span class="comment">// 把无序数列的边界更新为最后一次交换元素的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted) <span class="keyword">break</span>;                    <span class="comment">// 当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，退出排序</span></span><br><span class="line">        sortBorder = lastExchangeIndex;</span><br><span class="line">        System.out.println(sortBorder);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，冒泡排序法的分享就到此结束啦，下一次小V将会分享有关选择排序法方面的知识哦，走过路边不要错过哈！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/03/20/什么是冒泡排序法？/Bubble.jpg&quot; alt width=&quot;100%/&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://PeiJiaNi.coding.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://PeiJiaNi.coding.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="https://PeiJiaNi.coding.me/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分析与统计算法的执行效率和资源消耗</title>
    <link href="https://PeiJiaNi.coding.me/2019/03/13/%E5%88%86%E6%9E%90%E4%B8%8E%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97/"/>
    <id>https://PeiJiaNi.coding.me/2019/03/13/分析与统计算法的执行效率和资源消耗/</id>
    <published>2019-03-13T11:43:47.000Z</published>
    <updated>2019-05-03T07:12:35.436Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="分析与统计算法的执行效率和资源消耗">分析与统计算法的执行效率和资源消耗</span></h1><p> 我们都知道，学数据结构的其中一个目的就是为了我们的程序能跑的更”<strong>快</strong>“，占用的内存空间更<strong>“少”</strong>，那么我们应该如何来衡量这两项呢，这就需要用到接下来介绍的方法啦。</p><p>闲话少说，现在让我们通过一个小案例开始吧！</p><p><strong>Boss</strong>：小V，你帮我测试一下这两段完成相同功能代码，看看哪一段代码执行效率更高吧！</p><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic1.jpg" alt width="60%/"></p><a id="more"></a><p><strong>小V</strong>：好</p><p>有的同学可能会想到以下这个方法——通过分别记录执行每段前后的时间，通过两段代码消耗的时间得知执行效率（注：假设当前都是从1+2+…+100）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> startTime;</span><br><span class="line">    <span class="keyword">time_t</span> endTime;</span><br><span class="line">    time(&amp;startTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码段一 / 代码段二</span></span><br><span class="line"></span><br><span class="line">    time(&amp;endTime);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld"</span>,endTime-startTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看上去，小V同学的做法似乎没什么问题，但是仔细一想，这种测试方法实际上存在以下两种弊端：</p><ol><li><p><strong>测试.结果非常依赖测试环境</strong></p><p>比如，我们拿同样一段代码，在i3处理器上跑和在i7处理器上跑，结果显然易见，i7处理器的执行速度要比i3处理器快，也就是消耗的时间更少。</p></li><li><p><strong>测试结果也可能因数据规模的大小而受到影响</strong>（注：<strong>数据规模</strong>是指<strong>输入量</strong>或者说<strong>处理的数据量的多少</strong>）</p><p>比如，如果测试数据规模太小，测试结果可能无法真实地反应某个算法的执行效率(详细分析见下图)</p></li></ol><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic2.jpg" alt width="40%/"></p><p>​    如上图所示，如若我们数据规模为1，我们就会得出函数f(n) = 2n 的执行次数低于函数g(n) = n^2的执行次数，借此得出错误的结论：f(n) 的时间消耗 &gt; g(n)的时间消耗——&gt;f(n)效率 &gt; g(n)效率 </p><p>那么，既然以上方法这么不靠谱(实际上，以上这种不靠谱的分析、统计算法的名字叫<strong>事后统计法</strong>），那么我们后什么靠谱的统计方法呢，这就需要我们的<strong>事前分析估算法</strong>闪亮登场咯！</p><h2><span id="1-事前分析估算法">1、事前分析估算法</span></h2><p><strong>事前分析估算法：</strong>在编写程序前，依据统计方法对算法进行估算，</p><p>一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、算法采用的策略、方法；</span><br><span class="line">2、编译产生的代码质量；</span><br><span class="line">3、问题的输入规模；</span><br><span class="line">4、机器执行指令的速度；</span><br></pre></td></tr></table></figure></p><p>2和4这两个因素取决于软件和硬件因素，抛开这些，我们衡量一个程序执行时间，主要是通过<strong>算法的好坏</strong>以及<strong>数据规模的大小</strong>来得知。</p><h2><span id="2-何为大-o-复杂度表示法">2、何为大 O 复杂度表示法</span></h2><p>让我们通过前面Boss交给小V的那两个代码段来理解这一概念</p><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic3.jpg" alt width="70%/"></p><p>显然，第一个代码片段的执行次数为<strong>f(n) = 1+(n + 1)+n+1+1+1 = 2n + 4</strong>次，而第二个代码片段的执行次数为<strong>g(n)=1+1+1=3次</strong> ，假设执行一次的时间为uint_time，那么我们可以得出代码片段1的执行时间<strong>T1(n) = T(f(n)) = 2n+4</strong> unit_time，代码片段2的执行时间为 <strong>T2(n) = T(g(n)) = 3</strong> unit_time,至此，不难看出<strong>代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong> ，这其实也就是我们<strong>大 O 复杂度表示法</strong> 的定义！</p><center><strong>T(n)=T(f(n))</strong></center><p>它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称<strong>时间复杂度</strong>。其中f(n)是问题规模n的某个函数。(公式中的 O，<strong>表示代码的执行时间 T(n) 与 f(n) 代码的执行时间 T(n) 与 f(n) 表达式成正比</strong>）</p><h2><span id="3-时间复杂度分析">3、时间复杂度分析</span></h2><ol><li><p><strong>只关注循环执行次数最多的一段代码</strong><br> 栗子如下图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行的代码，行，所以这块代码要重点分析，通过分析本段代码块中循环次数最多的一段代码，这两行代码被执行了n次，所以不难得出总的时间复杂度为O(n)</p></li><li><p><strong>加法法则：总复杂度等于量级最大的那段代码的复杂度</strong><br> 让我们来分析如下代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">    sum_1 = sum_1 + p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">        sum_2 = sum_2 + q;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">        j = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">            sum_3 = sum_3 +  i * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>代码块分为三部分：</strong></p><pre><code>1. sum_1执行次数为100次，是一个常量的执行时间，与n的规模无关2. sum_2时间复杂度为O(n)3. sum_3时间复杂度为O(n^2)</code></pre><p> 所以总的时间复杂度为O(n）= O（n^2+n+100),结合<strong>“4、如何推导大O阶方法”</strong>不难得出该代码块的时间复杂度为O(n^2)</p></li><li><p><strong>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong><br> 栗子如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    ret = ret + f(i);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们先从cal()函数入手，假设 f() 只是一个普通操作，那第 4～6 行的时间复杂度就是O(n)，则整体的时间复杂度就为O(n),但f(n)并非一个简单操作，其内部是一个for循环，即外部循环每进行一次，内部执行n次操作，所以得出代码实际的时间复杂度为O(n^2) （即嵌套的双层for循环的时间复杂度）</p></li></ol><h2><span id="4-如何推导大o阶方法">4、如何推导大O阶方法</span></h2><ol><li>用常数1取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数。</li></ol><h2><span id="5-几种常见时间复杂度分析">5、<strong>几种常见时间复杂度分析</strong></span></h2><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic4.jpg" alt width="60%/"></p><p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。非多项式量级只有两个：O(2^n) 和 O(n!)。</p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，执行时间也会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。</p><p><strong>常数阶O(1)</strong></p><p>首先必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。</p><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic5.png" alt width="50%/"></p><p>注：顺序结构、分支结构基本都是常量阶</p><p><strong>线性阶O(n) (循环结构)</strong></p><p>切入点：要分析算法的复杂度，关键就是分析循环结构的运行情况</p><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic6.png" alt width="50%/"></p><p><strong>对数阶O(logn)与O(nlogn)</strong></p><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic7.png" alt width="50%/"></p><p>由于每次count乘以2之后，就离n更近了一步，也就是说，有多少个2相乘后大于n，则会退出循环。由2^x = n 得到 x =<br>log2^n。所以这个循环的时间复杂度为O(logn)</p><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic8.png" alt width="50%/"></p><p>很容易看出，该代码时间复杂度为O(log3^n)</p><p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？</p><p>我们知道，对数之间是可以互相转换的，由对数换底公式loga^b = loga^c <em> logc^b可得 log3^n =log3^2 </em> log2^n，所以 O(log3^n) = O(C * log2^n)，其中 C=log3^2 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2^n) = O(log3^n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p><p>理解了前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)</p><p><strong>平方阶O(n^2)</strong></p><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic8.png" alt width="50%/"></p><p>内层循环时间复杂度为O(n),再循环n次。所以这段代码的时间复杂度为O(n^2)。</p><p>如果外循环循环次数为m，时间复杂度就变为O(m * n)。</p><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic9.png" alt width="50%/"></p><p>总结：</p><p>O(1)&lt; O(log^n)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p><p><img src="/2019/03/13/分析与统计算法的执行效率和资源消耗/pic10.png" alt width="50%/"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分析与统计算法的执行效率和资源消耗&quot;&gt;&lt;a href=&quot;#分析与统计算法的执行效率和资源消耗&quot; class=&quot;headerlink&quot; title=&quot;分析与统计算法的执行效率和资源消耗&quot;&gt;&lt;/a&gt;分析与统计算法的执行效率和资源消耗&lt;/h1&gt;&lt;p&gt; 我们都知道，学数据结构的其中一个目的就是为了我们的程序能跑的更”&lt;strong&gt;快&lt;/strong&gt;“，占用的内存空间更&lt;strong&gt;“少”&lt;/strong&gt;，那么我们应该如何来衡量这两项呢，这就需要用到接下来介绍的方法啦。&lt;/p&gt;
&lt;p&gt;闲话少说，现在让我们通过一个小案例开始吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boss&lt;/strong&gt;：小V，你帮我测试一下这两段完成相同功能代码，看看哪一段代码执行效率更高吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/13/分析与统计算法的执行效率和资源消耗/pic1.jpg&quot; alt width=&quot;60%/&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://PeiJiaNi.coding.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://PeiJiaNi.coding.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法定义、特性及要求</title>
    <link href="https://PeiJiaNi.coding.me/2019/03/12/%E7%AE%97%E6%B3%95%E5%AE%9A%E4%B9%89%E3%80%81%E7%89%B9%E6%80%A7%E5%8F%8A%E8%A6%81%E6%B1%82/"/>
    <id>https://PeiJiaNi.coding.me/2019/03/12/算法定义、特性及要求/</id>
    <published>2019-03-12T13:37:01.000Z</published>
    <updated>2019-05-03T07:13:00.574Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="算法定义-特性及要求">算法定义、特性及要求</span></h1><h2><span id="1-算法定义">1、算法定义</span></h2><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><h2><span id="2-算法特性">2、算法特性</span></h2><p>1、输入输出</p><p>算法有零个或多个输入，至少有一个或多个输出。</p><a id="more"></a><p>2、有穷性</p><p>算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</p><p>3、确定性</p><p>算法的每一步骤都具有确定的含义，不会出现二义性。（同入同出）。</p><p>4、可行性</p><p>算法的每一步必须是可行的，也就是说，每一步都能够通过执行有限次数完成。</p><h2><span id="3-算法设计的要求">3、算法设计的要求</span></h2><p>1、正确性</p><p>算法的正确性是指算法至少应具有输入、输出及加工处理无歧义性、能正确反映问题需求、能得到问题的正确答案（即输入输出、确定性以及能解决问题）</p><ul><li>没有语法错误</li><li>对于合法的输入数据能够产生满足要求的输出结果</li><li>对于非法的输入数据能够得出满足规格说明的结果(衡量标准)</li><li>对于精心挑选的，甚至刁难的测试数据都有满足要求的输出结果</li></ul><p>2、可读性</p><p>方便阅读、理解与交流</p><p>3、健壮性</p><p>当输入数据不合法时，算法能做出相关处理，而不是产生异常或莫名其妙的结果</p><p>4、时间效率高和存储量低（空间效率高）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法定义、特性及要求&quot;&gt;&lt;a href=&quot;#算法定义、特性及要求&quot; class=&quot;headerlink&quot; title=&quot;算法定义、特性及要求&quot;&gt;&lt;/a&gt;算法定义、特性及要求&lt;/h1&gt;&lt;h2 id=&quot;1、算法定义&quot;&gt;&lt;a href=&quot;#1、算法定义&quot; class=&quot;headerlink&quot; title=&quot;1、算法定义&quot;&gt;&lt;/a&gt;1、算法定义&lt;/h2&gt;&lt;p&gt;算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。&lt;/p&gt;
&lt;h2 id=&quot;2、算法特性&quot;&gt;&lt;a href=&quot;#2、算法特性&quot; class=&quot;headerlink&quot; title=&quot;2、算法特性&quot;&gt;&lt;/a&gt;2、算法特性&lt;/h2&gt;&lt;p&gt;1、输入输出&lt;/p&gt;
&lt;p&gt;算法有零个或多个输入，至少有一个或多个输出。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://PeiJiaNi.coding.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://PeiJiaNi.coding.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基本概念</title>
    <link href="https://PeiJiaNi.coding.me/2019/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://PeiJiaNi.coding.me/2019/03/11/数据结构基本概念/</id>
    <published>2019-03-11T13:09:36.000Z</published>
    <updated>2019-05-03T07:12:12.115Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="1-数据结构基本概念和术语">1、数据结构基本概念和术语</span></h1><h2><span id="11-数据">1.1、数据</span></h2><p><strong>数据</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符合集合。数据，其实就是符号，而这些符号必须具备两个前提：</p><p>　1. 可以输入到计算机中。<br>　2. 能被计算机程序处理。</p><p><strong>数据包括</strong>：</p><ol><li>数值类型：整型、实型等；</li><li>非数值类型：字符及声音、图像、视频等；</li></ol><a id="more"></a><h2><span id="12-数据元素">1.2、数据元素</span></h2><p><strong>数据元素</strong>：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><pre><code>比如：    人类(数据)中，数据元素为人(组成该类)    畜类(数据)中，牛、马、羊等都是该类的数据元素(组成该类)</code></pre><h2><span id="13-数据项">1.3、数据项</span></h2><p><strong>数据项</strong>：一个数据元素可以由若干个数据项组成。数据项是数据<strong>不可分割</strong>的最小单位，但真正讨论问题时，<strong>数据元素才是数据结构中建立数据模型的着眼点</strong>。</p><pre><code>比如：　人(数据元素)可以有眼、耳、鼻、嘴、脚（数据项），也可以有姓名、性别（数据项）（具体要哪些数据项，要视系统决定）。</code></pre><h2><span id="14-数据对象">1.4、数据对象</span></h2><p>　<strong>数据对象</strong>：是性质相同（指数据元素具有<strong>相同数量</strong>和<strong>类型</strong>的数据项）的数据元素的集合，是数据的子集。</p><p>　数据对象为数据的子集，在实际应用中，处理的数据元素通常具有相同性质（即处理的是数据对象），所以，在不产生混淆的情况下，我们都讲数据对象简称为数据。</p><h2><span id="15-数据结构">1.5、数据结构</span></h2><p>总结：</p><p><img src="/2019/03/11/数据结构基本概念/data.png" alt="img"></p><h1><span id="2-逻辑结构和物理结构">2、逻辑结构和物理结构</span></h1><h2><span id="21-逻辑结构">2.1、逻辑结构</span></h2><p>​    逻辑结构是指数据对象中数据元素之间的相互关系。</p><h3><span id="211-分类">2.1.1、分类</span></h3><ul><li><strong>集合结构</strong>：集合结构中的数据元素除了同属于一个集合外，之间没有其他关系</li></ul><p><img src="/2019/03/11/数据结构基本概念/collection.png" alt="img"></p><ul><li><strong>线性结构</strong>：线性结构中的数据元素之间是一对一的关系</li></ul><p><img src="/2019/03/11/数据结构基本概念/linear.png" alt="img"></p><ul><li><strong>树形结构</strong>：树形结构中的数据元素存在一种一对多的层次关系</li></ul><p><img src="/2019/03/11/数据结构基本概念/tree.png" alt="img"></p><ul><li><strong>图型结构</strong>：图型结构的数据元素之间存在一种多对多的关系</li></ul><p><img src="/2019/03/11/数据结构基本概念/map.png" alt="img"></p><p><strong>注意</strong>：</p><p>​    使用示意图表示数据的逻辑结构时，将每一个数据元素看做一个结点，用圆圈表示</p><p>​    元素之间的逻辑关系用结点之间的连线表示，如果关系是有方向的，则用带箭头的连线表示</p><h2><span id="22-物理结构存储结构">2.2、物理结构（存储结构)</span></h2><p>  物理结构是指数据的逻辑结构在计算机中的存储方式（如何将逻辑结构转换为物理结构，即把数据元素存储到存储器中，存储结构应反映数据元素之间的逻辑关系）</p><p>分类：</p><ul><li>顺序存储结构：数据元素存放于地址连续的存储单元里，数据间的逻辑关系和物理关系是一致的</li></ul><p><img src="/2019/03/11/数据结构基本概念/SeqList.png" alt="img"></p><ul><li>链式存储结构：数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</li></ul><p><img src="/2019/03/11/数据结构基本概念/LinkList.png" alt="img"></p><p>总结：</p><p><img src="/2019/03/11/数据结构基本概念/Summary.png" alt="img"></p><h1><span id="3-抽象数据类型">3、抽象数据类型</span></h1><h2><span id="31-数据类型">3.1、数据类型</span></h2><p>​    数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p><h3><span id="311-数据类型分类">3.1.1、数据类型分类</span></h3><ul><li>原子类型：不可再分解的类型，包括实型，整型，字符型等</li><li>结构类型：由若干个类型组合而成，可分解。例如整型数组是由若干整型数据组成的。  </li></ul><h2><span id="32-抽象数据类型abstract-data-typeadt">3.2、抽象数据类型（Abstract Data Type,ADT）</span></h2><p>抽象数据类型是指一个数学模型及定义在该模型上的一组操作。一个抽象数据类型定义了：一个<strong>数据对象</strong>、数据<strong>对象中各数据元素之间的关系</strong>以及<strong>对数据元素的操作</strong>  (抽象：抽象是抽取出事物具有的普遍的本质。隐藏了繁杂的细节，只保留了实现目标所必须的信息。)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、数据结构基本概念和术语&quot;&gt;&lt;a href=&quot;#1、数据结构基本概念和术语&quot; class=&quot;headerlink&quot; title=&quot;1、数据结构基本概念和术语&quot;&gt;&lt;/a&gt;1、数据结构基本概念和术语&lt;/h1&gt;&lt;h2 id=&quot;1-1、数据&quot;&gt;&lt;a href=&quot;#1-1、数据&quot; class=&quot;headerlink&quot; title=&quot;1.1、数据&quot;&gt;&lt;/a&gt;1.1、数据&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符合集合。数据，其实就是符号，而这些符号必须具备两个前提：&lt;/p&gt;
&lt;p&gt;　1. 可以输入到计算机中。&lt;br&gt;　2. 能被计算机程序处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据包括&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数值类型：整型、实型等；&lt;/li&gt;
&lt;li&gt;非数值类型：字符及声音、图像、视频等；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://PeiJiaNi.coding.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://PeiJiaNi.coding.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
